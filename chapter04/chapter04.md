# 화면 전환

iOS에서 화면 전환 방법은 크게 두가지가 있다. 하나는 소스 코드를 통해 전환하는 방식이고, 다른 하나는 스토리보드가 제공하는 기능을 이용하여 전환하는 방식이다. 일반적으로 동적인 방식과 정적인 방식의 차이는 특정 상황에 대응할 수 있느냐 아니냐를 기준으로 나눈다. 동적인 방식은 일괄적으로 적용되는 것이라 특정 상황에 대응하기 어렵지만 그만큼 구현하기는 쉽다는 장점이 있다.

### 4.1 iOS 에서의 화면 전환 개념

iOS 에서 화면 전환 방식 4가지

    1. 뷰 컨트롤러의 뷰 위에 다른 뷰를 가져와 바꿔치기
    2. 뷰 컨트롤러에서 다른 뷰 컨트롤러를 호출하여 화면 전환하기
    3. 내비게이션 컨트롤러를 사용하여 화면 전환하기
    4. 화면 전환용 객체 세그웨이(Sequeway)를 사용하여 화면 전환하기

1번은 특수한 상황에서 제한적으로 사용하는 방식이다. 일부 뷰 컨트롤러들은 콘텐츠를 직접 배치하여 화면을 보여주는 역할 대신 다른 뷰 컨트롤러를 구조화하는 역할을 하는데, 이때 화면을 구조화 하는 방식이다. 이같은 뷰 컨트롤러를 컨테이너 뷰 컨트롤러라고 한다. 

1번을 제외한 나머지 대부분의 화면 전환은 모두 뷰 컨트롤러를 호출하는 방식인데, 현재의 화면이 다른 화면으로 완전히 교체되는 것이 아니라 현재 화면이 있는 상태에서 그 위에 새로운 화면을 얹는 것이다.

iOS 에서 화면 전환은 다음 두 가지 특성을 가진다.

    다음 화면으로 이동하는 방법과 이전 화면으로 되돌아가는 방법이 다름
    화면 전환 방식에 따라 이전 화면으로 되돌아가는 방법이 다름
    
다음화면으로 이동하는 과정은 기존 화면 위에 새로운 화면을 +1 하는 것이고, 이전 화면으로 되돌아가는 과정은 현재 상태에서 제일 위의 화면을 걷어내는 방식이므로 의미상 -1이다.

### 4.3 화면 전환 기법2 : 뷰 컨트롤러 직접 호출에 의한 화면 전환

현재의 뷰 컨트롤러에서 이동할 대상 뷰 컨트롤러를 직접 호출해서 화면을 표시하는 방법이다. 프레젠테이션 방식 이라고 부른다.
    
    present(<새로운 뷰컨트롤러 인스턴스>, animated : <애니메이션 여부>)
    
이 present 메소드는 두 개의 인자값을 입력받는데, 첫 번째 인자값은 새로운 화면을 담당하는 뷰 컨트롤러의 인스턴스이다. present 메소드는 입력받은 인스턴스를 사용하여 새로운 화면을 스크린에 나타냅니다. 화면을 전환할 때에는 필요에 따라 애니메이션 효과를 줄 수 있는데, 프레젠트 메소드의 두 번쨰 인자값이 이를 결정한다. 두 번째 인자값에 false 를 입력하면 아무런 효과없이 화면이 바뀌지만, true를 입력하면 화면 전환 시 애니메이션 효과가 적용됨. 떄로는 화면 전환이 완료되는 시점에 맞추어 특정 로직을 실행해 주어야 할 경우도 있다. 

    present(_: animated:completion:)

세 번째 매개변수는 실행 구문을 클로저나 함수 형식으로 입력받아, 화면 전환이 완전히 끝난 후에 호출해주는 역할이다. 화면 전환은 때로 시간이 걸리는 작업이라, 화면 전환 과정이 끝나기를 기다리지 않고 다음 라인에 작성된 코드를 이어서 실행하기 때문이다. 

이같이 하나의 처리를 끝나기를 기다리지 않고 다음 작업을 바로 이어서 수행하는 방식을 비동기 방식이라고 한다. 화면 전환은 비동기 방식으로 동작하기 떄문에, 화면 전환이 완전히 끝난 후에 실행해야 할 구문이 있다면 클로저나 함수 형식으로 작성하여 프레젠트 메소드의 세 번 째 인자값에 넣은 다음, 시스템이 알맞게 호출해 주기를 기다려야 한다.

프레젠트 메소드를 이용한 화면 전환은 기존의 뷰 컨트롤러를 그대로 둔 채, 그위에 새로운 뷰 컨트롤러의 화면을 덮는 방식이다.


화면을 전환할 때 프레젠트 메소드를 이용했다면, 이전 화면으로 복귀할 때는 dismiss(animated:) 복귀 메서드를 사용한다. 이전 화면으로 돌아가는 기능이기 때문에 뷰 컨트롤러의 인스턴스를 인자값으로 받지 않는다. 화면 복귀 시 애니메이션을 적용할지 말지를 결정하는 값만 전달해주면 되는 것이다. present 메소드를 이용해서 이전 화면을 호출할 경우 계속 메모리가 남아 앱이 불안정한 상태가 되기 때문에, 화면을 띄울 때 present 메소드를 사용했다면, 띄운 화면을 제거할 떄는 dismiss 메소드를 써야 한다.

### 4.3.1 화면 전환

뷰 컨트롤러를 통째로 보조 에디터로 드래그하여 @IBOutlet 으로 생성하면 되지 않겠냐 ? -> 뷰 컨트롤러를 참조하려면 스토리보드의 속성값을 이용해야 한다. 

            let uvc = self.storyboard!.instantiateViewController(withIdentifier: "SecondVC")

위의 코드는 self.storyboard 값이 옵셔널타입이다. 경우에 따라 값이 nil 일 수도 있다. 이 값을 nil 검사 없이 강제 해제를 할 경우 만약 self.storyboard 값이 nil 이면 오류가 발생한다.

코드를 보강하면 다음과 같다.

    guard let uvc = self.storyboard?.instantiateViewController(withIdentifier: "SecondVC") else {return}

뷰 컨트롤러 인스턴스는 moveNext 메소드 전체 실행에서 비어 있어서는 안되는 필수 조건이기 때문에 guard 조건문으로 필터링하기 좋다.

iOS에서의 화면 전환은 화면 자체가 교체되는 것이 아니라 기존의 화면이 있는 상태에서 새로운 화면이 그 위를 덮는 형태로 이루어지는데, self.present(_:animated:) 메소드(인스턴스가 있다.)가 그렇게 처리를 해주는 것이다. 화면을 복귀할 땐 dismiss(animated:) 메소드를 사용한다.

    
    전환할 때 : present(_:animated:) or present(_:animated:completion:)
    복귀할 때 : dismiss(animated:) or dismiss(animated:completion:)
    
Unwind : iOS 앱에서 이전 화면으로 돌아가는 것을 Unwind 라고 한다. 추가 참고자료 <https://velog.io/@wansook0316/Unwind-Segue>

### 4.4 내비게이션 컨트롤러를 이용한 화면 전환

내비게이션 컨트롤러는 뷰 컨트롤러의 특별한 종류로, 계층적인 성격을 띠는 콘텐츠 구조를 관리하기 위한 컨트롤러다. 내비게이션 바가 포함되어 있고 뷰 컨트롤러의 전환을 직접 컨트롤하고, 앱의 내비게이션 정보를 표시 하는 역할 뿐만 아니라 화면 전환이 발생하는 뷰 컨트롤러들이 포인터를 스택으로 관리하여 원하는 화면에 접근하기 쉽게 한다. 계층적 구조를 관리하는 역할이기에, 직접 콘텐츠를 담고 화면을 구성하지 않는다.

그런데 내비게이션 컨트롤러에서는 스택의 최상위에 있는 뷰 컨트롤러가 화면에 표시되므로, 결국 스택을 수정하여 최상위 뷰 컨트롤러를 더하거나 추가하는 것은 화면을 전환하는 것과 같다. 그래서 내비게이션 컨트롤러를 이용해서 화면을 전환할 때, 새로운 화면을 표시하려면 pushViewController(_:animated:), 이전 화면으로 돌아오려면 popViewController(animated:) 메소드를 호출하면 된다.

present() 메소드는 뷰 컨트롤러 자신을 대상으로 호출하는 반면, pushViewController() 메소드는 호출하는 대상이 내비게이션 컨트롤러이다.   

    실습 진행 중 스토리보드에서 뷰컨트롤러를 생성하고, 뷰컨트롤러 파일을 만들면 자동으로 연결이 되지 않는다. 스토리보드에서 뷰컨트롤러를 선택 후 보조 에디터의 4번째 클릭 후 커스텀 클래스에서 새로 생성한 뷰컨트롤러를 넣으면 된다.

present() 와 dismiss() 메소드의 호출 대상은 뷰 컨트롤러의 자신이지만, pushViewController() 와 popViewController() 메소드의 호출 대상은 내비게이션 컨트롤러이다.

### 4.5 세그웨이를 이용한 화면 전환

세그웨이(Segue) 라는 객체는 스토리보드에서 뷰 컨트롤러 사이의 연결 관계 및 화면 전환을 관리하는 역할이다. 화면과 화면을 연결하기 위해 아무런 소스 코드도 필요로 하지 않는다는 특징이 있는데, 뷰 컨트롤러와 뷰 컨트롤러 또는 화면 전환의 매개체가 되는 버튼과 뷰 컨트롤러 사이를 직접 연결하는 식으로 화면 전환 관계를 구성한다.

    출발점이 뷰 컨트롤러 자체인 경우는 메뉴얼 세그웨이(Manual Segue) 
    버튼 등이 출발점인 경우는 액션 세그웨이(Action Segue) or 트리거 세그웨이(Trigger Segue)
    
메뉴얼 세그웨이는 적절한 시점에 메소드를 호출하기만 하면 세그웨이가 실행되어 화면전환이 이루어 지지만, 액션 세그웨이(=트리거 세그웨이) 버튼의 터치 이벤트가 세그웨이 실행으로 바로 연결되므로, 소스 코드를 추가하지 않아도 화면 전환 기능을 구현할 수 있다.

### 4.5.1 액션 세그웨이

주로 버튼이나 테이블 셀 등의 컨트롤과 손가락으로 그리는 특정 패턴을 인식하는 제스처가 이에 해당한다. 액션 세그웨이는 화면 전환을 위해 프로그래밍 코드가 일절 필요하지 않고, 스토리보드에 구현된 객체를 트리거로 지정하기만 하면 되므로 전체적인 구성이 굉장히 단순해진다는 장점이 있다. 코드로 구성한 화면 이동보다 빠른 시간 내에 화면 이동을 구현할 수 있다.

 소스 코드를 이용하여 화면 전환을 처리하면 스토리보드에 아무런 표시가 남지 않아 화면끼리의 연결 관계를 유추하기 힘들지만, 세그웨이를 이용하면 이처럼 스토리보드에 화면 전환 관계가 명료하게 표시되므로 직관적으로 화면 사이의 관계를 파악할 수 있어 좋다.
 
 
### 4.5.2 메뉴얼 세그웨이

메뉴얼 세그웨이는 해당 이벤트만 발생하면 자동으로 실행되는 액션 세그웨이와는 달리 뷰 컨트롤러와 뷰 컨트롤러 사이에 연결되는 수동 실행 세그웨이이다. 액션 세그웨이는 트리거의 터치에 의해 실행되므로 별도의 처리 코드가 전혀 필요 없지만, 매뉴얼 세그웨이는 트리거 없이 수동으로 실행해야 하므로 소스 코드에서 세그웨이를 실행할 메소드를 호출해야 한다. 메소드는 다음과 같다

    performSegue(withIdentifier: <세그웨이 식별자>, sender: <세그웨이 실행 객체>)

### 4.5.3 Unwind - 화면 복귀

화면 전환을 하면서 이전 화면으로 되돌아가는 것을 Unwind 라고 한다. 첫 번쨰 뷰 컨트롤러에서 두 번째 뷰 컨트롤러로 세그웨이로 연결하듯, Unwind 도 그렇게 하면 되지 않을까 ? -> 결론은 안된다. 이는 세그웨이의 특성을 생각해보면 된다. 세그웨이는 목적지가 되는 뷰 컨트롤러의 인스턴스를 자동으로 생성한다. 역방향의 세그웨이를 다시 생성하는 것은 이미 존재하는 뷰 컨트롤러의 인스턴스를 또 다시 만들어 낸다는 의미이다. 동일한 뷰 컨트롤러가 중복되는 것이다. iOS 에서 뷰 컨트롤러의 인스턴스는 싱글톤 패턴이어야 한다.

    @IBAction func gotoPage1(unwindSegue: UIStoryboardSegue, towardsViewController : UIViewController) {
            몇버전부터 바뀐지는 모르겠는데, UIViewController 를 참조해야 된다.
    }

### 4.5.4 커스텀 세그웨이

 UIStoryboardSegue 클래스를 서브클래싱하여 새로운 기능을 갖춘 세그웨이 객체를 정의할 수 있도록 지원하는 세그웨이
 
     출발지 : self.source
     도착지 : self.destination
    
 transition() 은 타입 메소드이기 때문에 UIView 클래스의 인스턴스를 생성하지 않고도 호출할 수 있다. 

     UIView.transition(from: <출발지 뷰>, to: <목적지 뷰>, duration : <화면 전환에 소요되는 시간(단위 : 초), options : <애니메이션 전환 옵션>, completion : <화면 전환이 끝난 후 실행한 함수나 클로저 구문>)
     completion: 의 경우 화면 전환이 끝난 후에 처리할 내용이 있다면 사용한다.

### 4.5.5 전처리 메소드의 활용

세그웨이가 실행되기 전에 특정한 메소드를 호출하도록 설계되어 있기 때문에, 화면을 전환하기 전에 필요한 처리를 해줄 수 있다.

    prepare(for segue: UIStoryboardSegue, sender: Any?){
        ~~~
    }

세그웨이를 실행하기 전에 값을 저장해둘 필요가 있거나, 혹은 경고창을 띄워주는 등의 처리를 해야 할 경우 전처리 메소드에 해당 내용을 작성해놓으면 세그웨이가 실행되기 전에 자동으로 실행한다. 이 메소드의 호출 주체를 우리가 아니다. 우리가 구현해 놓으면 시스템이 호출하는 방식이다. 우리가 호출하고 싶을 때 임의로 호출하지 못한다는 의미로 해석하면 된다.
