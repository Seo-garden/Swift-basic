# 다른 뷰 컨트롤러와 데이터 주고받기

### 5.1 화면 전환 과정에서의 값 전달 방식

뷰 컨트롤러 사이에 값을 주고받는 방식은 두 가지 개념으로 나누어 볼 수 있다. 

하나는, 뷰 컨트롤러에서 다음 뷰 컨트롤러로 값을 직접 전달하는 방식이다. 또 다른 하나는 공통 저장소를 만들어 뷰 컨트롤러에서 여기에 값을 저장하고 화면을 이동하면 다음 뷰 컨트롤러에서 이 저장소를 열어 다시 값을 꺼내오는 공유 방식.

직접 전달 방식(동기 방식)

    주로 영속적으로 값을 저장할 필요가 없는 화면 전환에서 사용된다. 이 방식을 사용하게 되면 화면이 전환될 때 데이터가 함께 전달되거나 화면이 전환되기 전에 데이터가 미리 전달되므로 전달 과정에서 값이 누락될 염려가 없다는 장점이 있다. 때문에 저장소를 이용하여 값을 저장하는 방식보다 상대적으로 소스 코드가 간결해진다. 

간접 전달 방식(비동기 방식)

    반면에 저장소를 이용하여 값을 전달하는 방식은 주로 지속적으로 값을 저장할 필요가 있는 화면 전환에서 사용된다. 이 방식은 값을 계속 사용할 수 있게 저장해 놓는 데에는 좋지만, 저장소에 데이터가 저장되는 시점과 화면 전환 시점이 일어나지 않으면 값 전달이 제대로 안 될 수도 있다. 만약 저장소가 네트워크를 통한 외부에 있다면 이럴 가능성은 더욱 커진다. 따라서 값을 직접 전달하는 방식보다 상대적으로 소스 코드가 복잡해 질 수 있다. 
    
동기방식은 값을 전달받는 쪽의 뷰 컨트롤러가 전달받을 값의 명세를 모두 파악하고 이를 대입할 변수를 미리 생성해두어야 한다는 단점이 있다. 이를 보내는 뷰 컨트롤러에서는 받는 뷰 컨트롤러에 대한 정보를 미리 확인할 수 있어야 한다. 그래야 값을 직접 전달해줄 수 있다.

반면 비동기방식은 보내는 쪽과 받는 쪽 모두 저장소의 위치를 사전에 공유하고 있어야 한다는 부담이 있다. 값이 직접 전달하지 않고 저장소에 저장해두므로 받는 쪽에서도 저장소의 위치에 직접 접근해야 하기 때문이다. 사실, 저장소를 이용하는 방식은 값을 전달한다기보단 값을 저장하는 것에 가깝다.

### 5.2.1 화면 전환하면서 값을 전달하기

본래 액션 메소드를 정의할 때에는 매개변수 타입을 두 가지 방식 중에서 선택적으로 지정할 수 있다. Any 타입으로 선언하면 하나의 액션 메소드를 서로 다른 타입의 컨트롤들이 공용으로 사용할 수 있어 편리하지만 막상 해당 인자값을 사용해야 할 때에는 다시 하위 타입으로 캐스팅해주어야 하기 때문에 불편하다. 반면 개별 타입으로 선언해두면 해당 메소드는 이에 맞는 타입의 컨트롤만 호출할 수 있어 제한적이지만, 컨트롤의 속성을 제어하거나 읽어 들여야 할 경우 캐스팅할 필요 없이 바로 사용할 수 있다.

개별타입을 선택할 때
    
    액션 메소드를 호출한 컨트롤의 속성값이 필요하거나, 이를 제어해야 할 때
    
Any 타입을 선택해야 할 때

    서로 다른 타입의 컨트롤이 동일한 액션 메소드를 호출하게끔 처리하고 싶을 때
    액션 메소드를 호출한 컨트롤의 정보가 필요 없을 때
    개별 타입을 반드시 사용해야 하는 경우를 제외한 나머지 모든 경우
    
정리하면, 개별 타입을 사용해야 하는 경우는 명확하다. 인자값을 이용해서 무엇인가를 해야할때. 그 외의 경우는 Any 타입으로 지정한다.

화면 전환이 일어난 후 전달되는 값을 받기 위해 프로퍼티를 추가해야 한다. 아울렛 변수에 값을 바로 대입할 수 없는 여러 가지 이유가 있지만, 결정적으로 아울렛 변수는 외부에서 값을 직접 대입할 수 없는 변수다. 아울렛 변수는 외부 객체에서 직접 참조할 수 없도록 제한되어 있기 때문에 값을 대입할 프로퍼티를 따로 정의해야 한다.

    SubmitValue 프로젝트를 생성했다. 생성하자마자 생기는 뷰컨트롤러와 다음 페이지로 이동시키는 뷰컨트롤러2가 있다. 뷰컨트롤러2에 스토리보드ID 를 부여하고 뷰컨트롤러2.swift 를 만드는데 이때 뷰컨트롤러는 뷰컨트롤러2의 상위 클래스에 해당된다. 전환 대상의 프로퍼티를 참조하고 여기에 값을 대입해야 한다. ViewController 에서 ResultViewController 타입으로 캐스팅되는 과정은 다운캐스팅이다. 다운캐스팅과정에서 오류가 발생할 가능성이 항상 존재하기 때문에 옵셔널 캐스팅을 할지, 강제 캐스팅을 할지 결정하여 캐스팅 연산자 as 에 반영해야 한다. nil이 발생할 가능성을 열어두는 옵셔널 캐스팅과 nil이 발생할 가능성을 무시하는 강제캐스팅이다. 옵셔널 캐스팅으로 선택을 하고, 이 캐스팅의 결과는 항상 옵셔널 타입이므로 guard 구문 내에 옵셔녈 바인딩 처리를 해야 한다. 
    
### 5.3 이전 화면으로 값 전달하기

viewDidLoad() 메소드는 뷰 컨트롤러의 화면이 처음 만들어질 때 호출되는 메소드이다. 하지만 VC2 -> VC1 으로 전달할 때 VC1 이 새로 생성되는 인스턴스가 아니라 기존에 존재하는 인스턴스이다. 때문에 VC2 -> VC1 으로 화면을 viewDidLoad() 메소드가 호출되지 않는다. 

viewWillAppear() 메소드는 뷰 컨트롤러의 뷰가 화면에 표시될때 마다 실행되는 메소드이다. 즉 다른 화면으로 기존 화면을 가렸다가 다시 표시하면 이 메소드가 호출된다는 뜻이다. 물론, 처음 뷰 컨트롤러가 화면에 나타날때도 호출이 된다. 이때는 viewDidLoad() 메소드와 viewWillAppear() 메소드가 차례로 호출된다. 화면을 갱신할 때 마다 실행해야 하는 코드가 있다면 viewWillAppear() 내에 작성하면 된다.


