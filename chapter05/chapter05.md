# 다른 뷰 컨트롤러와 데이터 주고받기

### 5.1 화면 전환 과정에서의 값 전달 방식

뷰 컨트롤러 사이에 값을 주고받는 방식은 두 가지 개념으로 나누어 볼 수 있다. 

하나는, 뷰 컨트롤러에서 다음 뷰 컨트롤러로 값을 직접 전달하는 방식이다. 또 다른 하나는 공통 저장소를 만들어 뷰 컨트롤러에서 여기에 값을 저장하고 화면을 이동하면 다음 뷰 컨트롤러에서 이 저장소를 열어 다시 값을 꺼내오는 공유 방식.

직접 전달 방식(동기 방식)

    주로 영속적으로 값을 저장할 필요가 없는 화면 전환에서 사용된다. 이 방식을 사용하게 되면 화면이 전환될 때 데이터가 함께 전달되거나 화면이 전환되기 전에 데이터가 미리 전달되므로 전달 과정에서 값이 누락될 염려가 없다는 장점이 있다. 때문에 저장소를 이용하여 값을 저장하는 방식보다 상대적으로 소스 코드가 간결해진다. 

간접 전달 방식(비동기 방식)

    반면에 저장소를 이용하여 값을 전달하는 방식은 주로 지속적으로 값을 저장할 필요가 있는 화면 전환에서 사용된다. 이 방식은 값을 계속 사용할 수 있게 저장해 놓는 데에는 좋지만, 저장소에 데이터가 저장되는 시점과 화면 전환 시점이 일어나지 않으면 값 전달이 제대로 안 될 수도 있다. 만약 저장소가 네트워크를 통한 외부에 있다면 이럴 가능성은 더욱 커진다. 따라서 값을 직접 전달하는 방식보다 상대적으로 소스 코드가 복잡해 질 수 있다. 
    
동기방식은 값을 전달받는 쪽의 뷰 컨트롤러가 전달받을 값의 명세를 모두 파악하고 이를 대입할 변수를 미리 생성해두어야 한다는 단점이 있다. 이를 보내는 뷰 컨트롤러에서는 받는 뷰 컨트롤러에 대한 정보를 미리 확인할 수 있어야 한다. 그래야 값을 직접 전달해줄 수 있다.

반면 비동기방식은 보내는 쪽과 받는 쪽 모두 저장소의 위치를 사전에 공유하고 있어야 한다는 부담이 있다. 값이 직접 전달하지 않고 저장소에 저장해두므로 받는 쪽에서도 저장소의 위치에 직접 접근해야 하기 때문이다. 사실, 저장소를 이용하는 방식은 값을 전달한다기보단 값을 저장하는 것에 가깝다.

### 5.2.1 화면 전환하면서 값을 전달하기

본래 액션 메소드를 정의할 때에는 매개변수 타입을 두 가지 방식 중에서 선택적으로 지정할 수 있다. Any 타입으로 선언하면 하나의 액션 메소드를 서로 다른 타입의 컨트롤들이 공용으로 사용할 수 있어 편리하지만 막상 해당 인자값을 사용해야 할 때에는 다시 하위 타입으로 캐스팅해주어야 하기 때문에 불편하다. 반면 개별 타입으로 선언해두면 해당 메소드는 이에 맞는 타입의 컨트롤만 호출할 수 있어 제한적이지만, 컨트롤의 속성을 제어하거나 읽어 들여야 할 경우 캐스팅할 필요 없이 바로 사용할 수 있다.

개별타입을 선택할 때
    
    액션 메소드를 호출한 컨트롤의 속성값이 필요하거나, 이를 제어해야 할 때
    
Any 타입을 선택해야 할 때

    서로 다른 타입의 컨트롤이 동일한 액션 메소드를 호출하게끔 처리하고 싶을 때
    액션 메소드를 호출한 컨트롤의 정보가 필요 없을 때
    개별 타입을 반드시 사용해야 하는 경우를 제외한 나머지 모든 경우
    
정리하면, 개별 타입을 사용해야 하는 경우는 명확하다. 인자값을 이용해서 무엇인가를 해야할때. 그 외의 경우는 Any 타입으로 지정한다.

화면 전환이 일어난 후 전달되는 값을 받기 위해 프로퍼티를 추가해야 한다. 아울렛 변수에 값을 바로 대입할 수 없는 여러 가지 이유가 있지만, 결정적으로 아울렛 변수는 외부에서 값을 직접 대입할 수 없는 변수다. 아울렛 변수는 외부 객체에서 직접 참조할 수 없도록 제한되어 있기 때문에 값을 대입할 프로퍼티를 따로 정의해야 한다.

    SubmitValue 프로젝트를 생성했다. 생성하자마자 생기는 뷰컨트롤러와 다음 페이지로 이동시키는 뷰컨트롤러2가 있다. 뷰컨트롤러2에 스토리보드ID 를 부여하고 뷰컨트롤러2.swift 를 만드는데 이때 뷰컨트롤러는 뷰컨트롤러2의 상위 클래스에 해당된다. 전환 대상의 프로퍼티를 참조하고 여기에 값을 대입해야 한다. ViewController 에서 ResultViewController 타입으로 캐스팅되는 과정은 다운캐스팅이다. 다운캐스팅과정에서 오류가 발생할 가능성이 항상 존재하기 때문에 옵셔널 캐스팅을 할지, 강제 캐스팅을 할지 결정하여 캐스팅 연산자 as 에 반영해야 한다. nil이 발생할 가능성을 열어두는 옵셔널 캐스팅과 nil이 발생할 가능성을 무시하는 강제캐스팅이다. 옵셔널 캐스팅으로 선택을 하고, 이 캐스팅의 결과는 항상 옵셔널 타입이므로 guard 구문 내에 옵셔녈 바인딩 처리를 해야 한다. 
    
### 5.3 이전 화면으로 값 전달하기

viewDidLoad() 메소드는 뷰 컨트롤러의 화면이 처음 만들어질 때 호출되는 메소드이다. 하지만 VC2 -> VC1 으로 전달할 때 VC1 이 새로 생성되는 인스턴스가 아니라 기존에 존재하는 인스턴스이다. 때문에 VC2 -> VC1 으로 화면을 viewDidLoad() 메소드가 호출되지 않는다. 

viewWillAppear() 메소드는 뷰 컨트롤러의 뷰가 화면에 표시될때 마다 실행되는 메소드이다. 즉 다른 화면으로 기존 화면을 가렸다가 다시 표시하면 이 메소드가 호출된다는 뜻이다. 물론, 처음 뷰 컨트롤러가 화면에 나타날때도 호출이 된다. 이때는 viewDidLoad() 메소드와 viewWillAppear() 메소드가 차례로 호출된다. 화면을 갱신할 때 마다 실행해야 하는 코드가 있다면 viewWillAppear() 내에 작성하면 된다.

    SubmitValue-Back 프로젝트를 생성하고 실습하면서, 처음으로 viewWillAppear() 메소드를 사용했다. 하지만 이 메소드를 사용하려면 인스펙터에서 presentation 을 fullScreen 으로 해줘야 작동한다. 이거땜에 30분은 공식문서와 책을 찾아봤다.

### 5.3.2 저장소를 사용하여 값을 주고 받기

AppDelegate 객체에 저장한 값은 앱이 종료되기 전 까지만 유지가 된다. 앱이 종료되면 델리게이트에 저장된 값도 사라져 버리게 된다는 것이다. 이는 AppDelegate 객체에 저장한 값이 단순히 메모리에만 저장되기 때문에, 앱이 종료된 후에도 값을 보존하려면 반영구적으로 값을 저장할 수 있는 저장 객체를 사용해야 한다.

코코아 터치 프레임워크에서는 값을 반영구적으로 저장할 수 있도록 UserDefaults 객체(구.NSUserDefaults) 와 코어 데이터(Core Data) 객체를 제공한다. UserDefaults 객체는 비교적 간단한 데이터를 저장해두는데 사용되고, 코어 데이터 객체는 소규모 데이터베이스처럼 다소 복잡한 형태의 데이터를 저장하는데 사용된다. 파일에 저장되는 방법도 자주 사용되고, 네트워크를 통한 서버에 데이터를 전송하여 저장하는 방법도 있다.

AppDelegate 는 앱 전체에 통틀어 하나의 인스턴스만 존재하도록 iOS 시스템에 의해 보장된다. 이를 싱글톤이라고 표현하는데, 이러한 특성으로 인해 AppDelegate 에 직접 인스턴스를 생성할 수 없고, UIApplication.shared.delegate 구문을 통해 현재 생성되어 있는 인스턴스를 참조해야 된다. 경우에 따라 AppDelegate 클래스를 대신하는 다른 클래스를 만들어 같은 역할로 사용할 수도 있다. 다음과 같은 원칙이 존재한다.

    UIResponse 를 상속받는다
    UIApplicationDelegate protocol 을 채택해야 한다
    @UIApplicationMain 어노테이션을 붙혀야 한다.
    
앱 델리게이트 클래스 대신 코코아 터치 프레임워크에서 제공하는 UserDefaults 객체를 통해 값을 주고 받는 방법이 있다. 이 객체는 앱을 삭제하기 전까지 저장된 값이 반영구적으로 유지되는 장점이 있다.  이 객체는 비교적 단순하면서도 값이 유지되어야 하는 로그인 여부나 간단한 설정 정보 등을 저장하는 경우가 많다.

UserDefaults 는 시스템에서 자동으로 생성하여 제공하는 단일 객체이므로, 이 인스턴스는 지금까지의 일반적인 방법처럼 직접 생성하는 것이 아닌 UserDefaults.standard 프로퍼티를 사용해 읽어와야 한다. 클래스 프로퍼티이기 때문에 인스턴스를 생성하지 않고 사용한다.  UserDefaults 객체에는 set(_, forKey:) 스위프트의 기본 자료형을 그대로 저장할 수 있으므로 값의 타입을 변경해줄 필요는 없다.  

UserDefaults 객체에서 값을 읽어오는 메소드 중에서는 String 타입의 메소드만 반환값이 옵셔널 타입이다. 이와 달리 Bool 타입이나 Double 타입의 메소드는 일반 타입으로 값을 반환하기 때문에 옵셔널 해제 없이 바로 사용하면 된다. 아무 값도 저장되어 있지 않다면 각 타입별로 기본값을 반환하게 된다. 저장된 값의 타입이 어떤 것인지 정확하게 알기 어렵거나 메소드를 공용으로 사용할 때에는 범용 데이터 타입을 반환하는 메소드를 사용해도 된다. 
