# Delegate Pattern

객체지향 프로그래밍 에서는 객체 간의 관계가 중요한데, 설계에 관한 문제를 해결하기 위한 해법으로 객체들의 관계를 구조화한 사례가 일반화된 것이 바로 디자인패턴으로, 다양한 설계 문제를 합리적으로 해결하기 위한 목적으로 디자인 패턴들이 등장했다.  
특정 객체의 값이 바뀌었을 때 여러 객체에 이를 알려주기 위한 방법, 구조를 바꾸지 않고 기능을 변경하거나 개선하기 위한 방법, 하나의 객체만 생성하도록 보장하기 위한 방법 등이 이에 해당하는 문제들이라고 할 수 있다.

### Delegate 

델리게이트 패턴은 쉽게 말해 객체지향 프로그래밍에서 하나의 객체가 모든 일을 처리하는 것이 아니라 처리해야 할 일 중 일부를 다른 객체에 넘기는 것을 말한다. 효율성 관점에서 아주 중요한 역할을 한다. 기능을 위임할 수 있는 객체가 있다는 것은 그만큼 직접 구현해야 하는 부분이 적다는 뜻이기 때문에 큰 규모의 프로그램을 빠르게 작성할 수 있다. -> 모든 기능을 직접 처리해주려면 코딩양이 매우 늘어날 뿐더러 집중해야 할 부분에 집중을 하지 못한다. 기능을 분담하여 나누는 델리게이트 패턴이 필요한 이유이다.

iOS 에서 사용되는 델리게이트 패턴도 기능을 처리할 객체를 델리게이트로 설정하고, 특정 이벤트가 발생할 때 델리게이트에 의해 위임된 본래의 객체로 전달해주는 역할을 한다. 특정 이벤트가 발생했을 때 알려주는 방법이 바로 미리 정의된 델리게이트 메소드를 사용하는 것이다. iOS 에서 델리게이트 패턴을 사용하는 모든 객체는 델리게이트 메소드를 정의한 프로토콜을 가진다. 이를 델리게이트 프로토콜이라 하는데, 보통 객체의 이름 뒤에 Delegate를 붙여서 정의한다. 델리게이트 메소드를 이용하려면 델리게이트 프로토콜을 구현하는 과정이 반드시 필요하다. 

### 7.1 텍스트 필드

입력값을 제어하는 등의 고급 기능을 구현하고 싶을 때에는 델리게이트 패턴을 적용해야 한다. 특정 문자열의 입력 배제, 입력 가능한 문자열 길이 제한 등이 델리게이트 패턴을 통해 처리할 수 있는 대표적인 사례이다. 텍스트 필드에 델리게이트 패턴을 적용하려면 다음과 같은 작업이 필요하다

    텍스트 필드에 대한 델리게이트 프로토콜을 구현한다
    텍스트 필드의 델리게이트 속성을 뷰 컨트롤러에 연결한다
    
첫번째 작업은 프로토콜 구현에 관련된 것이다. 델리게이트 패턴을 구현하려면 모든 객체는 그에 맞는 델리게이트 프로토콜을 구현해야 한다. 프로토콜에 정의된 메소드를 실질적으로 작성하는 것까지를 포함한다. @optional 키워드가 붙은 메소드가 필요한 것만 선택적으로 구현해도 되지만, 이외의 메소드는 모두 반드시 구현해 주어야 한다. 
델리게이트 프로토콜을 구현하고 나면 이어지는 작업은 해당 객체의 델리게이트 속성을 뷰 컨트롤러와 연결하는 것이다. 델리게이트 속성이란, 델리게이트 메소드가 구현되어 있는 개체를 의미한다. 특정 이벤트가 발생했을 경우 텍스트 필드는 이를 알려주기 위해 델리게이트 메소드가 구현되어 있는 객체를 찾게 되는데, 이를 위한 참조 포인터가 저장되는 곳이 delegate 속성이다. 텍스트 필드의 delegate 속성에 저장된 인스턴스가 델리게이트 메소드를 구현한 것으로 인식하고, 필요한 메소드를 호출한다.

 
### 7.1.1 텍스트 필드의 특성 - 최초응답자

iOS 에서 모바일 기기의 디스플레이에 앱의 콘텐츠를 표현하기 위해 사용하는 UIWindow 객체는 사용자 인터페이스 구조에서 사용자에 가장 가까이 위치한 객체로, 사용자로부터 발생하는 터치 관련 이벤트를 내부 객체로 전달하는 역할을 담당한다. 특정 객체를 최초응답자로 만들고 싶다면 그 객체에 대한 becomeFirstResponder() 메소드를 호출하면 된다. 이 메소드는 UIResponder 클래스에 정의되어 있는데, 이 클래스를 상속받은 객체들은 모드 becomeFirstResponder() 메소드를 호출하여 최초응답자 객체가 될 수가 있다.

### 7.1.2 텍스트 필드에 델리게이트 패턴 적용하기

텍스트 필드의 delegate 는 텍스트 필드에 특정 이벤트가 발생했을 때 알려줄 대상 객체를 가리키는 속성이다. 이 속성에 대입된 self 는 현재 뷰 컨트롤러 인스턴스를 의미한다. 다시 말해, 텍스트 필드에서 미리 정해진 특정 이벤트가 발생하면 현재의 뷰 컨트롤러에게 알려달라는 요청이다. 이를 가리켜 "뷰 컨트롤러가 텍스트 필드의 델리게이트 객체로 지정되었다"라고 표현한다.

### 7.2.1 UIImagePickerController 클래스

이미지 피커 기능은 UIImagePickerController 클래스에 구현되어 있다. 빌더의 오브젝트 라이브러리에 포함되어 있지 않으므로 스토리보드를 이용하여 구성할 수 없으며, 소스코드를 사용하여 직접 인스턴스를 생성하고 화면을 호출해야 한다. 이미지 피커 컨트롤러를 사용하는 방식은 다음과 같다

    UIImagePickerController 클래스의 인스턴슬르 생성하고 여기에 기능 관련 속성을 설정한 후, present(_, animated:) 메소드에 인자값으로 넣어 호출하면 끝이다.

delegate 속성은 선택한 이미지를 반환받을 대상을 지정하는 속성이다. 속성값으로 self를 지정하면 이미지를 자기 자신의 뷰 컨트롤러로 받겠다는 의미이다. 선택한 이미지는 델리게이트 메소드를 통해 전달받게 되므로 이를 위해 델리게이트 프로토콜을 구현해야 한다. 

    UIImagePickerControllerDelegate 프로토콜
    UINavigationControllerDelegate 프로토콜
    
화면 전환 방식은 프레젠테이션 방식으로, 이미지 피커 실행을 종료하고 원래의 화면으로 복귀할 땐 dismiss(animated:) 메소드로 복귀하면 된다.

### 7.2.2 이미지 피커 컨트롤러의 델리게이트 메소드 

이미지 피커 컨트롤러가 호출하는 델리게이트 메소드는 크게 두가지 이다.

    imagePickerController(_:didFinishPickingMediaWithInfo:)
    imagePickerControllerDidCancel(_:)
    
첫 번째 메소드는 이미지 피커 컨트롤러에서 이미지를 선택하거나 카메라 촬영이 완료헀을 때 호출되는 메소드이다. 만약 선택한 이미지에 대한 수정 옵션이 설정되어 있다면 이미지 수정 작업이 완료되었을 때 호출된다. 
이 메소드는 두 개의 인자값을 전달하는데, 첫 번째 인자값은 이 메소드를 호출하는 이미지 피커 컨트롤러 객체이다. 하나의 뷰 컨트롤러에서 두 개 이상의 이미지 피커 컨트롤러를 사용하고 있을 경우, 첫 번째 인자값을 이용하여 어느 이미지 피커 컨트롤러가 호출된 것인지 확인할 수 있다. 두 번째 인자값은 우리가 원하는 이미지에 대한 데이터이다. 단순히 선택한 이미지가 아닌 이미지 객체에 대한 종합 정보가 딕셔너리 형태로 전달되므로 전달받은 인자값에 적절한 키를 사용하면 원하는 정보를 추출할 수 있다.

### 7.2.4 익스텐션(Extension) 을 이용한 델리게이트 패턴 구현

델리게이트 패턴은 최소한 하나 이상의 프로토콜을 구현해야 하기 때문에, 한 화면에서 다양한 객체의 델리게이트 패턴을 구현하다 보면 자칫 코드가 난잡해진다. 익스텐션(Extension)을 활용하면 깔끔하게 할 수 있다. 익스텐션은 클래스를 대신해서 프로토콜을 구현할 수 있기 때문에, 델리게이트 패턴에 사용되는 프로토콜을 익스텐션에서 구현하면 하나의 뷰 컨트롤러 클래스에 여러 프로토콜 메소드가 난립하는 것을 방지할 수 있다.

iOS 앱을 이루는 기본 아키텍처의 대부분은 델리게이터 패턴에 의존하고 있으므로, 이를 이해하지 못하면 대부분의 기능을 제대로 구현하기 어렵다. 따라서 델리게이트 패턴이 처리되는 방식과 코드 처리, 상호 의존 관계 등을 철저히 이해하여 동작 원리를 익혀둬야 한다. 
