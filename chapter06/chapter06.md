# 사용자에게 메세지를 전달하는 방법

모바일 서비스는 기본적으로 제작자와 사용자간의 대화이다. 하지만 때로는 보다 명시적인 메세지를 전달해야 될때가 있다. 서버 점검 때문에 일정 시간 동안 서비스 사용이 제한될 때 이를 안내하거나, 네트워크가 연결되지 않은 상태를 사용자에게 인지시키고, 한동안 접속하지 않은 사용자에게 초대 메시지를 보내는 둥의 경우가 있다.  다음은 대표적인 방법이다.
    
    메시지창(알림창)
    로컬 알림
    서버 알림(푸시 알림)

메시지창의 단점은 앱이 실행중인 경우에만 알림창을 노출할 수 있는 한계가 있다. 이를 보완하기 위해 고안된 것이 로컬 알림과 서버 알림 기능이다.  로컬 알림과 서버 알림은 푸시 메시지 기능이다. 공식 용어로 로컬 노티피케이션(로컬 푸시), 푸시 노티피케이션(서버 푸시)이라고 표현한다.  로컬 푸시가 앱 내부에서 특정 프로세스에 의해 등록된 메시지를 iOS 가 전달하는 방식이라면 서버 푸시는 별도의 서버를 통해 APNs(Apple Push Notification Service) 애플 고유의 메시징 시스템에게 보낸 메시지가 네트워크를 통해 전달되는 방식이다.

### 6.1 메시지 알림창 - UIAlertController

메시지창은 앱 실행 도중 사용자에게 메시지를 전달하고 의사를 입력받기 위한 목적으로 제공되는 객체다. UIAlertController 는 두 가지 형태의 메시지 창을 표현할 수 있다. 알림창은 화면 중앙, 액션 시트는 화면 하단에 표시된다는 차이점이 있고, 버튼이 두 개 일때 알림창은 이들 버튼을 나란히 배치하지만 액션 시트는 세로로 배치한다는 차이점이 존재한다.  알림창과 액션 시트 창의 결정적인 차이는 모달 여부이다. 알림창은 모달(Modal) 방식으로 화면에 표시되는 반면 액션 시트 창은 그렇지 않다. 모달이란 창이 닫힐 때 까지 그 창을 제외한 화면의 다른 부분은 반응할 수 없도록 잠기는 것이다. 즉 사용자가 알림창에 표시된 선택 버튼 중 어느 하나를 선택하기 전에는 다른 어떤 기능도 이용할 수 없다.  하지만 액션 시트창은 다르다. 메시지가 떠 있는 동안에도 메시지창이 아닌 다른 영역을 건드릴 수 있으며, 그 결과로 액션 시트 창이 닫히게 되는데, 즉 액션 시트창은 모달 방식이 아닌 것이다.
    
알림창이 표시되는 동안 코드가 계속 실행된다
    
    알림창이 애플리케이션의 실행 자체를 멈추는 것이 아니다. 이것은 UIAlertController가 비동기(Async) 방식으로 실행되는 것과 관련이 있다. 
    
### 6.1.1 UIAlertController 

메시지 창을 구현하는 과정에서는 UIAlertController 와 함께 UIAlertAction 도 함께 사용된다. UIAlertController 가 메시지 창을 그 자체를 담당한다면, UIAlertAction 은 메시지 창에 들어갈 버튼을 구현하는 객체다.


    UIAlertAction(title: "취소", style: .cancel, handler: {(_) in })
    사용자가 버튼을 클릭하면 세 번째 매개변수에 전달된 함수나 클로저가 실행된다. 이때 버튼 객체에 대한 참조 정보도 인자값으로 전달된다. 따라서 세 번째 매개번수에 사용되는 함수 또는 클로저는 UIAlertAction 타입의 인자값 하나를 입력받는 형식으로 정의되어 있어야 한다. 하지만 클로저를 통해 처리할 내용이 아무 것도 없다면 클로저의 매개변수는 언더바로 대체할 수 있다.

간혹 화면이 뜨자마자 자동으로 메시지 창을 띄워주어야 할 때가 있다. 네트워크 기반 서비스에서 네트워크가 연결되지 않았을 때가 대표적 경우인데, 이때에는 사용자의 액션 없이도 곧바로 메시지 창을 띄워 현재의 상태를 알려줘야 한다. viewDidLoad() 메소드 내에 메시지 창을 구현하여 실행하면 런타임 오류가 발생한다. 아직 메시지 창을 처리해줄 뷰가 화면에 구현되지 않은 상태에서 화면 전환을 시도 했기 때문인데, 이를 피하기 위해선 viewWillAppear() 메소드를 써주어야 한다. 뷰 객체가 메모리에만 올라온 상태에서 호출되는 viewDidLoad(_:) 메소드와 달리 viewAppear() 메소드는 뷰가 완전히 화면에 표현되고 난 다음에 호출되기 때문에 메시지 창을 띄우기 위한 프레젠트 메소드를 실행하는 데에 아무런 문제가 없다.

### 6.1.2 입력 필드를 가지는 메시지 창

텍스트 필드를 추가할 때에는 버튼처럼 별도의 객체를 생성하여 등록하는 방식이 아니라 addTextField(configuration Handler: )메소드를 호출하면 된다. 인자값으로는 클로저가 사용되는데, 이 클로저의 목적은 추가된 텍스트 필드의 속성을 설정하는 것이다. 따라서 클로저가 직접 참조할 수 있도록 텍스트 필드 객체 정보가 클로저의 인자값으로 전달된다. 클로저 블록 안에서 구현된 내용은 모두 텍스트 필드의 속성에 대한 설정이다. placeholder 속성은 텍스트 필드에 값이 비어 있을 때 안내 메시지 역할을 하고, isSecureTextEntry 속성은 비밀번호 입력 필드처럼 입력된 값을 * 처럼 처리하는 역할을 한다. 
