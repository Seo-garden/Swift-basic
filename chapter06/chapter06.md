# 사용자에게 메세지를 전달하는 방법

모바일 서비스는 기본적으로 제작자와 사용자간의 대화이다. 하지만 때로는 보다 명시적인 메세지를 전달해야 될때가 있다. 서버 점검 때문에 일정 시간 동안 서비스 사용이 제한될 때 이를 안내하거나, 네트워크가 연결되지 않은 상태를 사용자에게 인지시키고, 한동안 접속하지 않은 사용자에게 초대 메시지를 보내는 둥의 경우가 있다.  다음은 대표적인 방법이다.
    
    메시지창(알림창)
    로컬 알림
    서버 알림(푸시 알림)

메시지창의 단점은 앱이 실행중인 경우에만 알림창을 노출할 수 있는 한계가 있다. 이를 보완하기 위해 고안된 것이 로컬 알림과 서버 알림 기능이다.  로컬 알림과 서버 알림은 푸시 메시지 기능이다. 공식 용어로 로컬 노티피케이션(로컬 푸시), 푸시 노티피케이션(서버 푸시)이라고 표현한다.  로컬 푸시가 앱 내부에서 특정 프로세스에 의해 등록된 메시지를 iOS 가 전달하는 방식이라면 서버 푸시는 별도의 서버를 통해 APNs(Apple Push Notification Service) 애플 고유의 메시징 시스템에게 보낸 메시지가 네트워크를 통해 전달되는 방식이다.

### 6.1 메시지 알림창 - UIAlertController

메시지창은 앱 실행 도중 사용자에게 메시지를 전달하고 의사를 입력받기 위한 목적으로 제공되는 객체다. UIAlertController 는 두 가지 형태의 메시지 창을 표현할 수 있다. 알림창은 화면 중앙, 액션 시트는 화면 하단에 표시된다는 차이점이 있고, 버튼이 두 개 일때 알림창은 이들 버튼을 나란히 배치하지만 액션 시트는 세로로 배치한다는 차이점이 존재한다.  알림창과 액션 시트 창의 결정적인 차이는 모달 여부이다. 알림창은 모달(Modal) 방식으로 화면에 표시되는 반면 액션 시트 창은 그렇지 않다. 모달이란 창이 닫힐 때 까지 그 창을 제외한 화면의 다른 부분은 반응할 수 없도록 잠기는 것이다. 즉 사용자가 알림창에 표시된 선택 버튼 중 어느 하나를 선택하기 전에는 다른 어떤 기능도 이용할 수 없다.  하지만 액션 시트창은 다르다. 메시지가 떠 있는 동안에도 메시지창이 아닌 다른 영역을 건드릴 수 있으며, 그 결과로 액션 시트 창이 닫히게 되는데, 즉 액션 시트창은 모달 방식이 아닌 것이다.
    
알림창이 표시되는 동안 코드가 계속 실행된다
    
    알림창이 애플리케이션의 실행 자체를 멈추는 것이 아니다. 이것은 UIAlertController가 비동기(Async) 방식으로 실행되는 것과 관련이 있다. 
    
### 6.1.1 UIAlertController 

메시지 창을 구현하는 과정에서는 UIAlertController 와 함께 UIAlertAction 도 함께 사용된다. UIAlertController 가 메시지 창을 그 자체를 담당한다면, UIAlertAction 은 메시지 창에 들어갈 버튼을 구현하는 객체다.


    UIAlertAction(title: "취소", style: .cancel, handler: {(_) in })
    사용자가 버튼을 클릭하면 세 번째 매개변수에 전달된 함수나 클로저가 실행된다. 이때 버튼 객체에 대한 참조 정보도 인자값으로 전달된다. 따라서 세 번째 매개번수에 사용되는 함수 또는 클로저는 UIAlertAction 타입의 인자값 하나를 입력받는 형식으로 정의되어 있어야 한다. 하지만 클로저를 통해 처리할 내용이 아무 것도 없다면 클로저의 매개변수는 언더바로 대체할 수 있다.

간혹 화면이 뜨자마자 자동으로 메시지 창을 띄워주어야 할 때가 있다. 네트워크 기반 서비스에서 네트워크가 연결되지 않았을 때가 대표적 경우인데, 이때에는 사용자의 액션 없이도 곧바로 메시지 창을 띄워 현재의 상태를 알려줘야 한다. viewDidLoad() 메소드 내에 메시지 창을 구현하여 실행하면 런타임 오류가 발생한다. 아직 메시지 창을 처리해줄 뷰가 화면에 구현되지 않은 상태에서 화면 전환을 시도 했기 때문인데, 이를 피하기 위해선 viewWillAppear() 메소드를 써주어야 한다. 뷰 객체가 메모리에만 올라온 상태에서 호출되는 viewDidLoad(_:) 메소드와 달리 viewAppear() 메소드는 뷰가 완전히 화면에 표현되고 난 다음에 호출되기 때문에 메시지 창을 띄우기 위한 프레젠트 메소드를 실행하는 데에 아무런 문제가 없다.

### 6.1.2 입력 필드를 가지는 메시지 창

텍스트 필드를 추가할 때에는 버튼처럼 별도의 객체를 생성하여 등록하는 방식이 아니라 addTextField(configuration Handler: )메소드를 호출하면 된다. 인자값으로는 클로저가 사용되는데, 이 클로저의 목적은 추가된 텍스트 필드의 속성을 설정하는 것이다. 따라서 클로저가 직접 참조할 수 있도록 텍스트 필드 객체 정보가 클로저의 인자값으로 전달된다. 클로저 블록 안에서 구현된 내용은 모두 텍스트 필드의 속성에 대한 설정이다. placeholder 속성은 텍스트 필드에 값이 비어 있을 때 안내 메시지 역할을 하고, isSecureTextEntry 속성은 비밀번호 입력 필드처럼 입력된 값을 * 처럼 처리하는 역할을 한다. 

### 6.2 로컬 알림

로컬 알림은 앱 내부에서 만든 특정 메시지를 iOS의 알림 센터를 통해 전달하는 방법이다. 앱이 종료되어 있거나 백그라운드 상태일 때 메시지를 전달할 수 있는 대표적인 방법 중 하나이다.  로컬 알림은 iOS 스케줄러에 의해 발송되는데, 앱 내부에서 미리 메시지를 구성한 후 발송될 시각을 iOS 스케줄러에 등록 해두면 해당 시각에 맞춰 자동으로 발송된다.

### 6.2.1 UserNotification 프레임워크를 이용한 로컬 알림

UserNotification 은 사용자 알림을 처리하기 위한 알림 전용 프레임워크다. 알림을 위해 필요한 여러 가지 객체를 포함하고 있으며 UN 접두어를 사용하여 객체 이름을 정의한다. UserNotification 프레임워크는 UIKit , Foundation 프레임워크와 같은 수준의 독립된 프레임워크다. 다음은 UserNotification 프레임워크의 눈여겨봐야 할 객체다.

    1. UNMutableNotificationContent : 알림에 필요한 메시지와 같은 기본적인 속성을 담는 알림 콘텐츠 역할
    2. UNTimeIntervalNotificationTrigger :  알림 발송 조건을 관리
    3. UNNotificationRequest
    4. UNUserNotificationCenter
    
1번 객체를 통해 로컬 알림 타이틀, 서브 타이틀 및 알림 메시지를 설정할 수 있으며 앱 아이콘에 표시될 배지나 사운드 설정도 모두 이 객체를 통해 설정한다. 기존에 등록된 알림 콘텐츠를 읽을 때에만 사용할 수 있으며 속성을 설정하려면 반드시 UNMutableNotificationContent 객체를 사용해야 한다.  2번 객체가 설정할 수 있는 속성은 발생 시각과 반복 여부이다. UNTimeIntervalNotificationTrigger를 사용하면 "몇분 후" 등과 같이 시간 간격을 설정하여 알림 메시지를 발송할 수 있다. 만약 하루중 특정 시각에 맞춰 알림 메시지를 전송하고 싶다면 UNCalendarNotificationTrigger객체를 사용하면 된다.  1,2 를 통해 알림 콘텐츠와 알림 발생 조건이 준비되면 이들을 모아 알림 요청 객체를 만들어야 한다. 이때 사용되는 클래스는 UNNotificationRequest인데 알림 콘텐츠 객체와 알림 발송 조건 객체를 인자값으로 하여 이 클래스를 초기화하면 그 결과로 알림 요청 객체가 생성된다.  UNUserNotificationCenter 는 실제 발송을 담당하는 센터이다. 등록된 알림 내용을 확인하고 정해진 시각에 발송하는 역할을 한다. 이 객체는 싱글톤 방식으로 동작하기 때문에 따로 인스턴스를 생성하지 않고 current() 메소드를 통해 참조 정보만 가져올 수 있다.  

applicationWillResignActive(_:) 메소드는 앱이 활성화 상태를 잃었을 때 실행되는 메소드다. 앱은 여러 가지 이유로 활성화 상태를 잃고 비활성화 상태로 진입할 수 있는데, 앱을 사용하는 도중 전화가 오거나 SMS가 도착하는 경우, 또는 사용자가 홈 버튼을 눌러 앱을 백그라운드로 내렸을 때가 대표적인 경우이다.


    알림 권한 설정 > 알림 내용 설정(제목, 내용, 사운드, 뱃지) > 알림 조건 트리거 생성(시간 기반 트리거 or 캘린더 기반 트리거) > 알림 요청 생성 및 예약 > Delegate 구현(사용자에게 어떻게 처리할지)

### 6.2.3 받은 알림 처리하기

앱이 실행되는 도중에 알림 메시지가 도착할 경우 userNotificationCenter(_:willPresent:withCompletionHandler:) 메소드가 자동 호출된다. 따라서 이 메소드를 구현하면 우리는 앱 실행 도중에 알림 메시지가 도착했는지 알수 있으며, 원한다면 알림배너를 띄워줄 수도 있다. 앱 실행 중에도 알림 배너를 표시해주고 싶다면 해당 메소드를 구현해주어야 한다. 또한 사용자가 알림 메시지를 실제로 클릭하면 userNofiticationCenter(_:didReceive:withCompletionHandler:) 메소드가 자동으로 호출된다. 앱이 실행되는 중이던 미실행 상태이던 상관없이 동일하다. (이 메소드들은 UNUserNotificationCenterDelegate)프로토콜에 정의되어 있다.

 
    DispatchQueue.main.async{} : 백그라운드에서 실행되는 로직을 메인 쓰레드에서 실행하도록 처리해주는 역할을 한다. iOS의 프로그램 실행 영역은 UI 등의 주요 처리를 담당하는 메인 실행 영역과 그리 중요하지 않은 처리를 담당하는 백그라운드 실행 영역으로 나눠지는데, 대부분의 비동기 클로저 구문은 백그라운드 실행 영역에서 처리된다. 
    

